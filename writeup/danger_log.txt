
1. In the initial version of our project, we implemented CRUD statements for each fundamental operation. This approach functioned adequately under sequential execution conditions. However, when we subjected it to concurrent execution scenarios, it resulted in unpredictable outcomes.

2. We identified that our operations were essentially read-modify-write sequences, so we try to use mutex locks on the entire database table. Unfortunately, this approach not only failed to produce accurate outputs but also significantly reduced the performance, severely limiting the scalability of our application.

3. Then we tried to use database transactions. We make all the logic related to database operations within transactions and committing only after completing buy/sell/cancel operations. But this strategy led to a high coupling between the application logic and database operations, deviating from our design intentions.

4. Finally we chose to pass work W among all the database operation functions. This modification allowed us to manage concurrency more effectively.

5. With these adjustments, our server program now operates reliably under most conditions. However, it still encounters errors when subjected to extreme concurrent access, such as by several thousand threads simultaneously. To mitigate this, we are considering further optimizations to enhance the robustness and scalability of our system.


